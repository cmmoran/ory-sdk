// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * The version of the OpenAPI document: v1.4.0-alpha.0
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Ory.Kratos.Client.Client;
using Ory.Kratos.Client.Model;
using System.Diagnostics.CodeAnalysis;

namespace Ory.Kratos.Client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IIdentityApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        IdentityApiEvents Events { get; }

        /// <summary>
        /// Create multiple identities
        /// </summary>
        /// <remarks>
        /// Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model). This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>&gt;</returns>
        Task<IBatchPatchIdentitiesApiResponse> BatchPatchIdentitiesAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create multiple identities
        /// </summary>
        /// <remarks>
        /// Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model). This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </remarks>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>?&gt;</returns>
        Task<IBatchPatchIdentitiesApiResponse?> BatchPatchIdentitiesOrDefaultAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an Identity
        /// </summary>
        /// <remarks>
        /// Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>&gt;</returns>
        Task<ICreateIdentityApiResponse> CreateIdentityAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an Identity
        /// </summary>
        /// <remarks>
        /// Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </remarks>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>?&gt;</returns>
        Task<ICreateIdentityApiResponse?> CreateIdentityOrDefaultAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Code
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>&gt;</returns>
        Task<ICreateRecoveryCodeForIdentityApiResponse> CreateRecoveryCodeForIdentityAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Code
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>?&gt;</returns>
        Task<ICreateRecoveryCodeForIdentityApiResponse?> CreateRecoveryCodeForIdentityOrDefaultAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Link
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>&gt;</returns>
        Task<ICreateRecoveryLinkForIdentityApiResponse> CreateRecoveryLinkForIdentityAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Link
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>?&gt;</returns>
        Task<ICreateRecoveryLinkForIdentityApiResponse?> CreateRecoveryLinkForIdentityOrDefaultAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an Identity
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is assumed that is has been deleted already.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>&gt;</returns>
        Task<IDeleteIdentityApiResponse> DeleteIdentityAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an Identity
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is assumed that is has been deleted already.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>?&gt;</returns>
        Task<IDeleteIdentityApiResponse?> DeleteIdentityOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a credential for a specific identity
        /// </summary>
        /// <remarks>
        /// Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete password or code auth credentials through this API.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;oidc&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>&gt;</returns>
        Task<IDeleteIdentityCredentialsApiResponse> DeleteIdentityCredentialsAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a credential for a specific identity
        /// </summary>
        /// <remarks>
        /// Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete password or code auth credentials through this API.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;oidc&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>?&gt;</returns>
        Task<IDeleteIdentityCredentialsApiResponse?> DeleteIdentityCredentialsOrDefaultAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>&gt;</returns>
        Task<IDeleteIdentitySessionsApiResponse> DeleteIdentitySessionsAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>?&gt;</returns>
        Task<IDeleteIdentitySessionsApiResponse?> DeleteIdentitySessionsOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deactivate a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>&gt;</returns>
        Task<IDisableSessionApiResponse> DisableSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deactivate a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </remarks>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>?&gt;</returns>
        Task<IDisableSessionApiResponse?> DisableSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Extend a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>&gt;</returns>
        Task<IExtendSessionApiResponse> ExtendSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Extend a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </remarks>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>?&gt;</returns>
        Task<IExtendSessionApiResponse?> ExtendSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Identity
        /// </summary>
        /// <remarks>
        /// Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>&gt;</returns>
        Task<IGetIdentityApiResponse> GetIdentityAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Identity
        /// </summary>
        /// <remarks>
        /// Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>?&gt;</returns>
        Task<IGetIdentityApiResponse?> GetIdentityOrDefaultAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Identity JSON Schema
        /// </summary>
        /// <remarks>
        /// Return a specific identity schema.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>&gt;</returns>
        Task<IGetIdentitySchemaApiResponse> GetIdentitySchemaAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Identity JSON Schema
        /// </summary>
        /// <remarks>
        /// Return a specific identity schema.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>?&gt;</returns>
        Task<IGetIdentitySchemaApiResponse?> GetIdentitySchemaOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Session
        /// </summary>
        /// <remarks>
        /// This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>&gt;</returns>
        Task<IGetSessionApiResponse> GetSessionAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Session
        /// </summary>
        /// <remarks>
        /// This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </remarks>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>?&gt;</returns>
        Task<IGetSessionApiResponse?> GetSessionOrDefaultAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Identities
        /// </summary>
        /// <remarks>
        /// Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>&gt;</returns>
        Task<IListIdentitiesApiResponse> ListIdentitiesAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Identities
        /// </summary>
        /// <remarks>
        /// Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </remarks>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>?&gt;</returns>
        Task<IListIdentitiesApiResponse?> ListIdentitiesOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List an Identity&#39;s trusted devices
        /// </summary>
        /// <remarks>
        /// This endpoint returns all trusted devices for any sessions that belong to the given Identity.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentityDevicesApiResponse"/>&gt;</returns>
        Task<IListIdentityDevicesApiResponse> ListIdentityDevicesAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List an Identity&#39;s trusted devices
        /// </summary>
        /// <remarks>
        /// This endpoint returns all trusted devices for any sessions that belong to the given Identity.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentityDevicesApiResponse"/>?&gt;</returns>
        Task<IListIdentityDevicesApiResponse?> ListIdentityDevicesOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Identity Schemas
        /// </summary>
        /// <remarks>
        /// Returns a list of all identity schemas currently in use.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>&gt;</returns>
        Task<IListIdentitySchemasApiResponse> ListIdentitySchemasAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Identity Schemas
        /// </summary>
        /// <remarks>
        /// Returns a list of all identity schemas currently in use.
        /// </remarks>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>?&gt;</returns>
        Task<IListIdentitySchemasApiResponse?> ListIdentitySchemasOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// This endpoint returns all sessions that belong to the given Identity.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>&gt;</returns>
        Task<IListIdentitySessionsApiResponse> ListIdentitySessionsAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// This endpoint returns all sessions that belong to the given Identity.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>?&gt;</returns>
        Task<IListIdentitySessionsApiResponse?> ListIdentitySessionsOrDefaultAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Sessions
        /// </summary>
        /// <remarks>
        /// Listing all sessions that exist.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>&gt;</returns>
        Task<IListSessionsApiResponse> ListSessionsAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Sessions
        /// </summary>
        /// <remarks>
        /// Listing all sessions that exist.
        /// </remarks>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>?&gt;</returns>
        Task<IListSessionsApiResponse?> ListSessionsOrDefaultAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Patch an Identity
        /// </summary>
        /// <remarks>
        /// Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>&gt;</returns>
        Task<IPatchIdentityApiResponse> PatchIdentityAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Patch an Identity
        /// </summary>
        /// <remarks>
        /// Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>?&gt;</returns>
        Task<IPatchIdentityApiResponse?> PatchIdentityOrDefaultAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Patch an Identity&#39;s devices
        /// </summary>
        /// <remarks>
        /// Partially updates an identity&#39;s device&#39;s trusted field using [JSON Patch](https://jsonpatch.com/). Only the field &#x60;trusted&#x60; can be updated using this method. Even that can only be set to &#x60;false&#x60; using this method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="deviceId">DeviceID is the Identity&#39;s Device&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityDevicesApiResponse"/>&gt;</returns>
        Task<IPatchIdentityDevicesApiResponse> PatchIdentityDevicesAsync(string id, string deviceId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Patch an Identity&#39;s devices
        /// </summary>
        /// <remarks>
        /// Partially updates an identity&#39;s device&#39;s trusted field using [JSON Patch](https://jsonpatch.com/). Only the field &#x60;trusted&#x60; can be updated using this method. Even that can only be set to &#x60;false&#x60; using this method.
        /// </remarks>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="deviceId">DeviceID is the Identity&#39;s Device&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityDevicesApiResponse"/>?&gt;</returns>
        Task<IPatchIdentityDevicesApiResponse?> PatchIdentityDevicesOrDefaultAsync(string id, string deviceId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an Identity
        /// </summary>
        /// <remarks>
        /// This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload (except credentials) is expected. It is possible to update the identity&#39;s credentials as well.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>&gt;</returns>
        Task<IUpdateIdentityApiResponse> UpdateIdentityAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an Identity
        /// </summary>
        /// <remarks>
        /// This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload (except credentials) is expected. It is possible to update the identity&#39;s credentials as well.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>?&gt;</returns>
        Task<IUpdateIdentityApiResponse?> UpdateIdentityOrDefaultAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IBatchPatchIdentitiesApiResponse"/>
    /// </summary>
    public interface IBatchPatchIdentitiesApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Ory.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="ICreateIdentityApiResponse"/>
    /// </summary>
    public interface ICreateIdentityApiResponse : Ory.Kratos.Client.Client.IApiResponse, ICreated<Ory.Kratos.Client.Model.KratosIdentity?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="ICreateRecoveryCodeForIdentityApiResponse"/>
    /// </summary>
    public interface ICreateRecoveryCodeForIdentityApiResponse : Ory.Kratos.Client.Client.IApiResponse, ICreated<Ory.Kratos.Client.Model.KratosRecoveryCodeForIdentity?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="ICreateRecoveryLinkForIdentityApiResponse"/>
    /// </summary>
    public interface ICreateRecoveryLinkForIdentityApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Ory.Kratos.Client.Model.KratosRecoveryLinkForIdentity?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteIdentityApiResponse"/>
    /// </summary>
    public interface IDeleteIdentityApiResponse : Ory.Kratos.Client.Client.IApiResponse, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteIdentityCredentialsApiResponse"/>
    /// </summary>
    public interface IDeleteIdentityCredentialsApiResponse : Ory.Kratos.Client.Client.IApiResponse, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteIdentitySessionsApiResponse"/>
    /// </summary>
    public interface IDeleteIdentitySessionsApiResponse : Ory.Kratos.Client.Client.IApiResponse, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IUnauthorized<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDisableSessionApiResponse"/>
    /// </summary>
    public interface IDisableSessionApiResponse : Ory.Kratos.Client.Client.IApiResponse, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IUnauthorized<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IExtendSessionApiResponse"/>
    /// </summary>
    public interface IExtendSessionApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Ory.Kratos.Client.Model.KratosSession?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetIdentityApiResponse"/>
    /// </summary>
    public interface IGetIdentityApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Ory.Kratos.Client.Model.KratosIdentity?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetIdentitySchemaApiResponse"/>
    /// </summary>
    public interface IGetIdentitySchemaApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Object?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetSessionApiResponse"/>
    /// </summary>
    public interface IGetSessionApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Ory.Kratos.Client.Model.KratosSession?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListIdentitiesApiResponse"/>
    /// </summary>
    public interface IListIdentitiesApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<List<KratosIdentity>?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListIdentityDevicesApiResponse"/>
    /// </summary>
    public interface IListIdentityDevicesApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<List<KratosSessionDevice>?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListIdentitySchemasApiResponse"/>
    /// </summary>
    public interface IListIdentitySchemasApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<List<KratosIdentitySchemaContainer>?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListIdentitySessionsApiResponse"/>
    /// </summary>
    public interface IListIdentitySessionsApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<List<KratosSession>?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListSessionsApiResponse"/>
    /// </summary>
    public interface IListSessionsApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<List<KratosSession>?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IPatchIdentityApiResponse"/>
    /// </summary>
    public interface IPatchIdentityApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Ory.Kratos.Client.Model.KratosIdentity?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IPatchIdentityDevicesApiResponse"/>
    /// </summary>
    public interface IPatchIdentityDevicesApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<List<KratosSessionDevice>?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateIdentityApiResponse"/>
    /// </summary>
    public interface IUpdateIdentityApiResponse : Ory.Kratos.Client.Client.IApiResponse, IOk<Ory.Kratos.Client.Model.KratosIdentity?>, IBadRequest<Ory.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<Ory.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<Ory.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class IdentityApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBatchPatchIdentities;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBatchPatchIdentities;

        internal void ExecuteOnBatchPatchIdentities(IdentityApi.BatchPatchIdentitiesApiResponse apiResponse)
        {
            OnBatchPatchIdentities?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBatchPatchIdentities(Exception exception)
        {
            OnErrorBatchPatchIdentities?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateIdentity;

        internal void ExecuteOnCreateIdentity(IdentityApi.CreateIdentityApiResponse apiResponse)
        {
            OnCreateIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateIdentity(Exception exception)
        {
            OnErrorCreateIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateRecoveryCodeForIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateRecoveryCodeForIdentity;

        internal void ExecuteOnCreateRecoveryCodeForIdentity(IdentityApi.CreateRecoveryCodeForIdentityApiResponse apiResponse)
        {
            OnCreateRecoveryCodeForIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateRecoveryCodeForIdentity(Exception exception)
        {
            OnErrorCreateRecoveryCodeForIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateRecoveryLinkForIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateRecoveryLinkForIdentity;

        internal void ExecuteOnCreateRecoveryLinkForIdentity(IdentityApi.CreateRecoveryLinkForIdentityApiResponse apiResponse)
        {
            OnCreateRecoveryLinkForIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateRecoveryLinkForIdentity(Exception exception)
        {
            OnErrorCreateRecoveryLinkForIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteIdentity;

        internal void ExecuteOnDeleteIdentity(IdentityApi.DeleteIdentityApiResponse apiResponse)
        {
            OnDeleteIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteIdentity(Exception exception)
        {
            OnErrorDeleteIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteIdentityCredentials;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteIdentityCredentials;

        internal void ExecuteOnDeleteIdentityCredentials(IdentityApi.DeleteIdentityCredentialsApiResponse apiResponse)
        {
            OnDeleteIdentityCredentials?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteIdentityCredentials(Exception exception)
        {
            OnErrorDeleteIdentityCredentials?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteIdentitySessions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteIdentitySessions;

        internal void ExecuteOnDeleteIdentitySessions(IdentityApi.DeleteIdentitySessionsApiResponse apiResponse)
        {
            OnDeleteIdentitySessions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteIdentitySessions(Exception exception)
        {
            OnErrorDeleteIdentitySessions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDisableSession;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDisableSession;

        internal void ExecuteOnDisableSession(IdentityApi.DisableSessionApiResponse apiResponse)
        {
            OnDisableSession?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDisableSession(Exception exception)
        {
            OnErrorDisableSession?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnExtendSession;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorExtendSession;

        internal void ExecuteOnExtendSession(IdentityApi.ExtendSessionApiResponse apiResponse)
        {
            OnExtendSession?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorExtendSession(Exception exception)
        {
            OnErrorExtendSession?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetIdentity;

        internal void ExecuteOnGetIdentity(IdentityApi.GetIdentityApiResponse apiResponse)
        {
            OnGetIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetIdentity(Exception exception)
        {
            OnErrorGetIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetIdentitySchema;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetIdentitySchema;

        internal void ExecuteOnGetIdentitySchema(IdentityApi.GetIdentitySchemaApiResponse apiResponse)
        {
            OnGetIdentitySchema?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetIdentitySchema(Exception exception)
        {
            OnErrorGetIdentitySchema?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSession;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSession;

        internal void ExecuteOnGetSession(IdentityApi.GetSessionApiResponse apiResponse)
        {
            OnGetSession?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSession(Exception exception)
        {
            OnErrorGetSession?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListIdentities;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListIdentities;

        internal void ExecuteOnListIdentities(IdentityApi.ListIdentitiesApiResponse apiResponse)
        {
            OnListIdentities?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListIdentities(Exception exception)
        {
            OnErrorListIdentities?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListIdentityDevices;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListIdentityDevices;

        internal void ExecuteOnListIdentityDevices(IdentityApi.ListIdentityDevicesApiResponse apiResponse)
        {
            OnListIdentityDevices?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListIdentityDevices(Exception exception)
        {
            OnErrorListIdentityDevices?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListIdentitySchemas;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListIdentitySchemas;

        internal void ExecuteOnListIdentitySchemas(IdentityApi.ListIdentitySchemasApiResponse apiResponse)
        {
            OnListIdentitySchemas?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListIdentitySchemas(Exception exception)
        {
            OnErrorListIdentitySchemas?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListIdentitySessions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListIdentitySessions;

        internal void ExecuteOnListIdentitySessions(IdentityApi.ListIdentitySessionsApiResponse apiResponse)
        {
            OnListIdentitySessions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListIdentitySessions(Exception exception)
        {
            OnErrorListIdentitySessions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListSessions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListSessions;

        internal void ExecuteOnListSessions(IdentityApi.ListSessionsApiResponse apiResponse)
        {
            OnListSessions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListSessions(Exception exception)
        {
            OnErrorListSessions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPatchIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPatchIdentity;

        internal void ExecuteOnPatchIdentity(IdentityApi.PatchIdentityApiResponse apiResponse)
        {
            OnPatchIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPatchIdentity(Exception exception)
        {
            OnErrorPatchIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPatchIdentityDevices;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPatchIdentityDevices;

        internal void ExecuteOnPatchIdentityDevices(IdentityApi.PatchIdentityDevicesApiResponse apiResponse)
        {
            OnPatchIdentityDevices?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPatchIdentityDevices(Exception exception)
        {
            OnErrorPatchIdentityDevices?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateIdentity;

        internal void ExecuteOnUpdateIdentity(IdentityApi.UpdateIdentityApiResponse apiResponse)
        {
            OnUpdateIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateIdentity(Exception exception)
        {
            OnErrorUpdateIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class IdentityApi : IIdentityApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<IdentityApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public IdentityApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="IdentityApi"/> class.
        /// </summary>
        /// <returns></returns>
        public IdentityApi(ILogger<IdentityApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, IdentityApiEvents identityApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<IdentityApi>();
            HttpClient = httpClient;
            Events = identityApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatBatchPatchIdentities(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="kratosPatchIdentitiesBody"></param>
        /// <returns></returns>
        private void ValidateBatchPatchIdentities(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody)
        {
            if (kratosPatchIdentitiesBody.IsSet && kratosPatchIdentitiesBody.Value == null)
                throw new ArgumentNullException(nameof(kratosPatchIdentitiesBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        private void AfterBatchPatchIdentitiesDefaultImplementation(IBatchPatchIdentitiesApiResponse apiResponseLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody)
        {
            bool suppressDefaultLog = false;
            AfterBatchPatchIdentities(ref suppressDefaultLog, apiResponseLocalVar, kratosPatchIdentitiesBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        partial void AfterBatchPatchIdentities(ref bool suppressDefaultLog, IBatchPatchIdentitiesApiResponse apiResponseLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        private void OnErrorBatchPatchIdentitiesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBatchPatchIdentities(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, kratosPatchIdentitiesBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        partial void OnErrorBatchPatchIdentities(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody);

        /// <summary>
        /// Create multiple identities Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model). This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </summary>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IBatchPatchIdentitiesApiResponse?> BatchPatchIdentitiesOrDefaultAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BatchPatchIdentitiesAsync(kratosPatchIdentitiesBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create multiple identities Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model). This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IBatchPatchIdentitiesApiResponse> BatchPatchIdentitiesAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateBatchPatchIdentities(kratosPatchIdentitiesBody);

                FormatBatchPatchIdentities(kratosPatchIdentitiesBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities";

                    if (kratosPatchIdentitiesBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosPatchIdentitiesBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosPatchIdentitiesBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<BatchPatchIdentitiesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BatchPatchIdentitiesApiResponse>();

                        BatchPatchIdentitiesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterBatchPatchIdentitiesDefaultImplementation(apiResponseLocalVar, kratosPatchIdentitiesBody);

                        Events.ExecuteOnBatchPatchIdentities(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBatchPatchIdentitiesDefaultImplementation(e, "/admin/identities", uriBuilderLocalVar.Path, kratosPatchIdentitiesBody);
                Events.ExecuteOnErrorBatchPatchIdentities(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BatchPatchIdentitiesApiResponse"/>
        /// </summary>
        public partial class BatchPatchIdentitiesApiResponse : Ory.Kratos.Client.Client.ApiResponse, IBatchPatchIdentitiesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BatchPatchIdentitiesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BatchPatchIdentitiesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BatchPatchIdentitiesApiResponse(ILogger<BatchPatchIdentitiesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateIdentity(Option<KratosCreateIdentityBody> kratosCreateIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="kratosCreateIdentityBody"></param>
        /// <returns></returns>
        private void ValidateCreateIdentity(Option<KratosCreateIdentityBody> kratosCreateIdentityBody)
        {
            if (kratosCreateIdentityBody.IsSet && kratosCreateIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosCreateIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        private void AfterCreateIdentityDefaultImplementation(ICreateIdentityApiResponse apiResponseLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateIdentity(ref suppressDefaultLog, apiResponseLocalVar, kratosCreateIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        partial void AfterCreateIdentity(ref bool suppressDefaultLog, ICreateIdentityApiResponse apiResponseLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        private void OnErrorCreateIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, kratosCreateIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        partial void OnErrorCreateIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody);

        /// <summary>
        /// Create an Identity Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </summary>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateIdentityApiResponse?> CreateIdentityOrDefaultAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateIdentityAsync(kratosCreateIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an Identity Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateIdentityApiResponse> CreateIdentityAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateIdentity(kratosCreateIdentityBody);

                FormatCreateIdentity(kratosCreateIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities";

                    if (kratosCreateIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosCreateIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosCreateIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateIdentityApiResponse>();

                        CreateIdentityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateIdentityDefaultImplementation(apiResponseLocalVar, kratosCreateIdentityBody);

                        Events.ExecuteOnCreateIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateIdentityDefaultImplementation(e, "/admin/identities", uriBuilderLocalVar.Path, kratosCreateIdentityBody);
                Events.ExecuteOnErrorCreateIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateIdentityApiResponse"/>
        /// </summary>
        public partial class CreateIdentityApiResponse : Ory.Kratos.Client.Client.ApiResponse, ICreateIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateIdentityApiResponse(ILogger<CreateIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosIdentity? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsCreated && !IsBadRequest && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateRecoveryCodeForIdentity(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        /// <returns></returns>
        private void ValidateCreateRecoveryCodeForIdentity(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody)
        {
            if (kratosCreateRecoveryCodeForIdentityBody.IsSet && kratosCreateRecoveryCodeForIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosCreateRecoveryCodeForIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        private void AfterCreateRecoveryCodeForIdentityDefaultImplementation(ICreateRecoveryCodeForIdentityApiResponse apiResponseLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateRecoveryCodeForIdentity(ref suppressDefaultLog, apiResponseLocalVar, kratosCreateRecoveryCodeForIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        partial void AfterCreateRecoveryCodeForIdentity(ref bool suppressDefaultLog, ICreateRecoveryCodeForIdentityApiResponse apiResponseLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        private void OnErrorCreateRecoveryCodeForIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateRecoveryCodeForIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, kratosCreateRecoveryCodeForIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        partial void OnErrorCreateRecoveryCodeForIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody);

        /// <summary>
        /// Create a Recovery Code This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryCodeForIdentityApiResponse?> CreateRecoveryCodeForIdentityOrDefaultAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateRecoveryCodeForIdentityAsync(kratosCreateRecoveryCodeForIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Recovery Code This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryCodeForIdentityApiResponse> CreateRecoveryCodeForIdentityAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateRecoveryCodeForIdentity(kratosCreateRecoveryCodeForIdentityBody);

                FormatCreateRecoveryCodeForIdentity(kratosCreateRecoveryCodeForIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/recovery/code";

                    if (kratosCreateRecoveryCodeForIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosCreateRecoveryCodeForIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosCreateRecoveryCodeForIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateRecoveryCodeForIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateRecoveryCodeForIdentityApiResponse>();

                        CreateRecoveryCodeForIdentityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/recovery/code", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateRecoveryCodeForIdentityDefaultImplementation(apiResponseLocalVar, kratosCreateRecoveryCodeForIdentityBody);

                        Events.ExecuteOnCreateRecoveryCodeForIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateRecoveryCodeForIdentityDefaultImplementation(e, "/admin/recovery/code", uriBuilderLocalVar.Path, kratosCreateRecoveryCodeForIdentityBody);
                Events.ExecuteOnErrorCreateRecoveryCodeForIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateRecoveryCodeForIdentityApiResponse"/>
        /// </summary>
        public partial class CreateRecoveryCodeForIdentityApiResponse : Ory.Kratos.Client.Client.ApiResponse, ICreateRecoveryCodeForIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateRecoveryCodeForIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateRecoveryCodeForIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRecoveryCodeForIdentityApiResponse(ILogger<CreateRecoveryCodeForIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosRecoveryCodeForIdentity? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosRecoveryCodeForIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosRecoveryCodeForIdentity? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsCreated && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateRecoveryLinkForIdentity(ref Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        /// <returns></returns>
        private void ValidateCreateRecoveryLinkForIdentity(Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody)
        {
            if (returnTo.IsSet && returnTo.Value == null)
                throw new ArgumentNullException(nameof(returnTo));

            if (kratosCreateRecoveryLinkForIdentityBody.IsSet && kratosCreateRecoveryLinkForIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosCreateRecoveryLinkForIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        private void AfterCreateRecoveryLinkForIdentityDefaultImplementation(ICreateRecoveryLinkForIdentityApiResponse apiResponseLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateRecoveryLinkForIdentity(ref suppressDefaultLog, apiResponseLocalVar, returnTo, kratosCreateRecoveryLinkForIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        partial void AfterCreateRecoveryLinkForIdentity(ref bool suppressDefaultLog, ICreateRecoveryLinkForIdentityApiResponse apiResponseLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        private void OnErrorCreateRecoveryLinkForIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateRecoveryLinkForIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnTo, kratosCreateRecoveryLinkForIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        partial void OnErrorCreateRecoveryLinkForIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody);

        /// <summary>
        /// Create a Recovery Link This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryLinkForIdentityApiResponse?> CreateRecoveryLinkForIdentityOrDefaultAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateRecoveryLinkForIdentityAsync(returnTo, kratosCreateRecoveryLinkForIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Recovery Link This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryLinkForIdentityApiResponse> CreateRecoveryLinkForIdentityAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateRecoveryLinkForIdentity(returnTo, kratosCreateRecoveryLinkForIdentityBody);

                FormatCreateRecoveryLinkForIdentity(ref returnTo, kratosCreateRecoveryLinkForIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/recovery/link";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (returnTo.IsSet)
                        parseQueryStringLocalVar["return_to"] = ClientUtils.ParameterToString(returnTo.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (kratosCreateRecoveryLinkForIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosCreateRecoveryLinkForIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosCreateRecoveryLinkForIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateRecoveryLinkForIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateRecoveryLinkForIdentityApiResponse>();

                        CreateRecoveryLinkForIdentityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/recovery/link", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateRecoveryLinkForIdentityDefaultImplementation(apiResponseLocalVar, returnTo, kratosCreateRecoveryLinkForIdentityBody);

                        Events.ExecuteOnCreateRecoveryLinkForIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateRecoveryLinkForIdentityDefaultImplementation(e, "/admin/recovery/link", uriBuilderLocalVar.Path, returnTo, kratosCreateRecoveryLinkForIdentityBody);
                Events.ExecuteOnErrorCreateRecoveryLinkForIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateRecoveryLinkForIdentityApiResponse"/>
        /// </summary>
        public partial class CreateRecoveryLinkForIdentityApiResponse : Ory.Kratos.Client.Client.ApiResponse, ICreateRecoveryLinkForIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateRecoveryLinkForIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateRecoveryLinkForIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRecoveryLinkForIdentityApiResponse(ILogger<CreateRecoveryLinkForIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosRecoveryLinkForIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosRecoveryLinkForIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosRecoveryLinkForIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteIdentity(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteIdentity(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteIdentityDefaultImplementation(IDeleteIdentityApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteIdentity(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteIdentity(ref bool suppressDefaultLog, IDeleteIdentityApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Delete an Identity Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is assumed that is has been deleted already.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityApiResponse?> DeleteIdentityOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteIdentityAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an Identity Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is assumed that is has been deleted already.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityApiResponse> DeleteIdentityAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteIdentity(id);

                FormatDeleteIdentity(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteIdentityApiResponse>();

                        DeleteIdentityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteIdentityDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteIdentityApiResponse"/>
        /// </summary>
        public partial class DeleteIdentityApiResponse : Ory.Kratos.Client.Client.ApiResponse, IDeleteIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentityApiResponse(ILogger<DeleteIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteIdentityCredentials(ref string id, ref string type, ref Option<string> identifier);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        /// <returns></returns>
        private void ValidateDeleteIdentityCredentials(string id, string type, Option<string> identifier)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (type == null)
                throw new ArgumentNullException(nameof(type));

            if (identifier.IsSet && identifier.Value == null)
                throw new ArgumentNullException(nameof(identifier));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        private void AfterDeleteIdentityCredentialsDefaultImplementation(IDeleteIdentityCredentialsApiResponse apiResponseLocalVar, string id, string type, Option<string> identifier)
        {
            bool suppressDefaultLog = false;
            AfterDeleteIdentityCredentials(ref suppressDefaultLog, apiResponseLocalVar, id, type, identifier);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        partial void AfterDeleteIdentityCredentials(ref bool suppressDefaultLog, IDeleteIdentityCredentialsApiResponse apiResponseLocalVar, string id, string type, Option<string> identifier);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        private void OnErrorDeleteIdentityCredentialsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string type, Option<string> identifier)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteIdentityCredentials(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, type, identifier);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        partial void OnErrorDeleteIdentityCredentials(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string type, Option<string> identifier);

        /// <summary>
        /// Delete a credential for a specific identity Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete password or code auth credentials through this API.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;oidc&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityCredentialsApiResponse?> DeleteIdentityCredentialsOrDefaultAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteIdentityCredentialsAsync(id, type, identifier, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a credential for a specific identity Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete password or code auth credentials through this API.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;oidc&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityCredentialsApiResponse> DeleteIdentityCredentialsAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteIdentityCredentials(id, type, identifier);

                FormatDeleteIdentityCredentials(ref id, ref type, ref identifier);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}/credentials/{type}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btype%7D", Uri.EscapeDataString(type.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (identifier.IsSet)
                        parseQueryStringLocalVar["identifier"] = ClientUtils.ParameterToString(identifier.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteIdentityCredentialsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteIdentityCredentialsApiResponse>();

                        DeleteIdentityCredentialsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/credentials/{type}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteIdentityCredentialsDefaultImplementation(apiResponseLocalVar, id, type, identifier);

                        Events.ExecuteOnDeleteIdentityCredentials(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteIdentityCredentialsDefaultImplementation(e, "/admin/identities/{id}/credentials/{type}", uriBuilderLocalVar.Path, id, type, identifier);
                Events.ExecuteOnErrorDeleteIdentityCredentials(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteIdentityCredentialsApiResponse"/>
        /// </summary>
        public partial class DeleteIdentityCredentialsApiResponse : Ory.Kratos.Client.Client.ApiResponse, IDeleteIdentityCredentialsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteIdentityCredentialsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteIdentityCredentialsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentityCredentialsApiResponse(ILogger<DeleteIdentityCredentialsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteIdentitySessions(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteIdentitySessions(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteIdentitySessionsDefaultImplementation(IDeleteIdentitySessionsApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteIdentitySessions(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteIdentitySessions(ref bool suppressDefaultLog, IDeleteIdentitySessionsApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteIdentitySessionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteIdentitySessions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteIdentitySessions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentitySessionsApiResponse?> DeleteIdentitySessionsOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteIdentitySessionsAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentitySessionsApiResponse> DeleteIdentitySessionsAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteIdentitySessions(id);

                FormatDeleteIdentitySessions(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}/sessions";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteIdentitySessionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteIdentitySessionsApiResponse>();

                        DeleteIdentitySessionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/sessions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteIdentitySessionsDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteIdentitySessions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteIdentitySessionsDefaultImplementation(e, "/admin/identities/{id}/sessions", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteIdentitySessions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteIdentitySessionsApiResponse"/>
        /// </summary>
        public partial class DeleteIdentitySessionsApiResponse : Ory.Kratos.Client.Client.ApiResponse, IDeleteIdentitySessionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteIdentitySessionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteIdentitySessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentitySessionsApiResponse(ILogger<DeleteIdentitySessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsBadRequest && !IsUnauthorized && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDisableSession(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDisableSession(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDisableSessionDefaultImplementation(IDisableSessionApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDisableSession(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDisableSession(ref bool suppressDefaultLog, IDisableSessionApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDisableSessionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDisableSession(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDisableSession(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Deactivate a Session Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </summary>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>&gt;</returns>
        public async Task<IDisableSessionApiResponse?> DisableSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DisableSessionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deactivate a Session Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>&gt;</returns>
        public async Task<IDisableSessionApiResponse> DisableSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDisableSession(id);

                FormatDisableSession(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/sessions/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DisableSessionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DisableSessionApiResponse>();

                        DisableSessionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDisableSessionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDisableSession(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDisableSessionDefaultImplementation(e, "/admin/sessions/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDisableSession(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DisableSessionApiResponse"/>
        /// </summary>
        public partial class DisableSessionApiResponse : Ory.Kratos.Client.Client.ApiResponse, IDisableSessionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DisableSessionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DisableSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DisableSessionApiResponse(ILogger<DisableSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsBadRequest && !IsUnauthorized;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatExtendSession(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateExtendSession(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterExtendSessionDefaultImplementation(IExtendSessionApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterExtendSession(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterExtendSession(ref bool suppressDefaultLog, IExtendSessionApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorExtendSessionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorExtendSession(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorExtendSession(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Extend a Session Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </summary>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>&gt;</returns>
        public async Task<IExtendSessionApiResponse?> ExtendSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ExtendSessionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Extend a Session Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>&gt;</returns>
        public async Task<IExtendSessionApiResponse> ExtendSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateExtendSession(id);

                FormatExtendSession(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/sessions/{id}/extend";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ExtendSessionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ExtendSessionApiResponse>();

                        ExtendSessionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions/{id}/extend", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterExtendSessionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnExtendSession(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorExtendSessionDefaultImplementation(e, "/admin/sessions/{id}/extend", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorExtendSession(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ExtendSessionApiResponse"/>
        /// </summary>
        public partial class ExtendSessionApiResponse : Ory.Kratos.Client.Client.ApiResponse, IExtendSessionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ExtendSessionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ExtendSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ExtendSessionApiResponse(ILogger<ExtendSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosSession? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosSession>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosSession? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsNoContent && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetIdentity(ref string id, Option<List<string>> includeCredential);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        /// <returns></returns>
        private void ValidateGetIdentity(string id, Option<List<string>> includeCredential)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (includeCredential.IsSet && includeCredential.Value == null)
                throw new ArgumentNullException(nameof(includeCredential));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        private void AfterGetIdentityDefaultImplementation(IGetIdentityApiResponse apiResponseLocalVar, string id, Option<List<string>> includeCredential)
        {
            bool suppressDefaultLog = false;
            AfterGetIdentity(ref suppressDefaultLog, apiResponseLocalVar, id, includeCredential);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        partial void AfterGetIdentity(ref bool suppressDefaultLog, IGetIdentityApiResponse apiResponseLocalVar, string id, Option<List<string>> includeCredential);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        private void OnErrorGetIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> includeCredential)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, includeCredential);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        partial void OnErrorGetIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> includeCredential);

        /// <summary>
        /// Get an Identity Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </summary>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>&gt;</returns>
        public async Task<IGetIdentityApiResponse?> GetIdentityOrDefaultAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetIdentityAsync(id, includeCredential, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Identity Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>&gt;</returns>
        public async Task<IGetIdentityApiResponse> GetIdentityAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetIdentity(id, includeCredential);

                FormatGetIdentity(ref id, includeCredential);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (includeCredential.IsSet)
                        parseQueryStringLocalVar["include_credential"] = ClientUtils.ParameterToString(includeCredential.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetIdentityApiResponse>();

                        GetIdentityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetIdentityDefaultImplementation(apiResponseLocalVar, id, includeCredential);

                        Events.ExecuteOnGetIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id, includeCredential);
                Events.ExecuteOnErrorGetIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetIdentityApiResponse"/>
        /// </summary>
        public partial class GetIdentityApiResponse : Ory.Kratos.Client.Client.ApiResponse, IGetIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentityApiResponse(ILogger<GetIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetIdentitySchema(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateGetIdentitySchema(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetIdentitySchemaDefaultImplementation(IGetIdentitySchemaApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterGetIdentitySchema(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetIdentitySchema(ref bool suppressDefaultLog, IGetIdentitySchemaApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetIdentitySchemaDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetIdentitySchema(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetIdentitySchema(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Get Identity JSON Schema Return a specific identity schema.
        /// </summary>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>&gt;</returns>
        public async Task<IGetIdentitySchemaApiResponse?> GetIdentitySchemaOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetIdentitySchemaAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Identity JSON Schema Return a specific identity schema.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>&gt;</returns>
        public async Task<IGetIdentitySchemaApiResponse> GetIdentitySchemaAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetIdentitySchema(id);

                FormatGetIdentitySchema(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/schemas/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetIdentitySchemaApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetIdentitySchemaApiResponse>();

                        GetIdentitySchemaApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schemas/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetIdentitySchemaDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetIdentitySchema(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetIdentitySchemaDefaultImplementation(e, "/schemas/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetIdentitySchema(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetIdentitySchemaApiResponse"/>
        /// </summary>
        public partial class GetIdentitySchemaApiResponse : Ory.Kratos.Client.Client.ApiResponse, IGetIdentitySchemaApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetIdentitySchemaApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetIdentitySchemaApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentitySchemaApiResponse(ILogger<GetIdentitySchemaApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Object? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Object>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Object? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSession(ref string id, Option<List<string>> expand);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        /// <returns></returns>
        private void ValidateGetSession(string id, Option<List<string>> expand)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (expand.IsSet && expand.Value == null)
                throw new ArgumentNullException(nameof(expand));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        private void AfterGetSessionDefaultImplementation(IGetSessionApiResponse apiResponseLocalVar, string id, Option<List<string>> expand)
        {
            bool suppressDefaultLog = false;
            AfterGetSession(ref suppressDefaultLog, apiResponseLocalVar, id, expand);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        partial void AfterGetSession(ref bool suppressDefaultLog, IGetSessionApiResponse apiResponseLocalVar, string id, Option<List<string>> expand);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        private void OnErrorGetSessionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> expand)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSession(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, expand);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        partial void OnErrorGetSession(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> expand);

        /// <summary>
        /// Get Session This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </summary>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>&gt;</returns>
        public async Task<IGetSessionApiResponse?> GetSessionOrDefaultAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSessionAsync(id, expand, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Session This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>&gt;</returns>
        public async Task<IGetSessionApiResponse> GetSessionAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSession(id, expand);

                FormatGetSession(ref id, expand);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/sessions/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (expand.IsSet)
                        parseQueryStringLocalVar["expand"] = ClientUtils.ParameterToString(expand.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetSessionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSessionApiResponse>();

                        GetSessionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetSessionDefaultImplementation(apiResponseLocalVar, id, expand);

                        Events.ExecuteOnGetSession(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSessionDefaultImplementation(e, "/admin/sessions/{id}", uriBuilderLocalVar.Path, id, expand);
                Events.ExecuteOnErrorGetSession(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSessionApiResponse"/>
        /// </summary>
        public partial class GetSessionApiResponse : Ory.Kratos.Client.Client.ApiResponse, IGetSessionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSessionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSessionApiResponse(ILogger<GetSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosSession? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosSession>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosSession? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListIdentities(ref Option<long> perPage, ref Option<long> page, ref Option<long> pageSize, ref Option<string> pageToken, ref Option<string> consistency, Option<List<string>> ids, ref Option<string> credentialsIdentifier, ref Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, ref Option<string> organizationId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        /// <returns></returns>
        private void ValidateListIdentities(Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId)
        {
            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));

            if (consistency.IsSet && consistency.Value == null)
                throw new ArgumentNullException(nameof(consistency));

            if (ids.IsSet && ids.Value == null)
                throw new ArgumentNullException(nameof(ids));

            if (credentialsIdentifier.IsSet && credentialsIdentifier.Value == null)
                throw new ArgumentNullException(nameof(credentialsIdentifier));

            if (previewCredentialsIdentifierSimilar.IsSet && previewCredentialsIdentifierSimilar.Value == null)
                throw new ArgumentNullException(nameof(previewCredentialsIdentifierSimilar));

            if (includeCredential.IsSet && includeCredential.Value == null)
                throw new ArgumentNullException(nameof(includeCredential));

            if (organizationId.IsSet && organizationId.Value == null)
                throw new ArgumentNullException(nameof(organizationId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        private void AfterListIdentitiesDefaultImplementation(IListIdentitiesApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId)
        {
            bool suppressDefaultLog = false;
            AfterListIdentities(ref suppressDefaultLog, apiResponseLocalVar, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        partial void AfterListIdentities(ref bool suppressDefaultLog, IListIdentitiesApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        private void OnErrorListIdentitiesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListIdentities(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        partial void OnErrorListIdentities(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId);

        /// <summary>
        /// List Identities Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </summary>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IListIdentitiesApiResponse?> ListIdentitiesOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListIdentitiesAsync(perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List Identities Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IListIdentitiesApiResponse> ListIdentitiesAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListIdentities(pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);

                FormatListIdentities(ref perPage, ref page, ref pageSize, ref pageToken, ref consistency, ids, ref credentialsIdentifier, ref previewCredentialsIdentifierSimilar, includeCredential, ref organizationId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    if (consistency.IsSet)
                        parseQueryStringLocalVar["consistency"] = ClientUtils.ParameterToString(consistency.Value);

                    if (ids.IsSet)
                        parseQueryStringLocalVar["ids"] = ClientUtils.ParameterToString(ids.Value);

                    if (credentialsIdentifier.IsSet)
                        parseQueryStringLocalVar["credentials_identifier"] = ClientUtils.ParameterToString(credentialsIdentifier.Value);

                    if (previewCredentialsIdentifierSimilar.IsSet)
                        parseQueryStringLocalVar["preview_credentials_identifier_similar"] = ClientUtils.ParameterToString(previewCredentialsIdentifierSimilar.Value);

                    if (includeCredential.IsSet)
                        parseQueryStringLocalVar["include_credential"] = ClientUtils.ParameterToString(includeCredential.Value);

                    if (organizationId.IsSet)
                        parseQueryStringLocalVar["organization_id"] = ClientUtils.ParameterToString(organizationId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListIdentitiesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListIdentitiesApiResponse>();

                        ListIdentitiesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListIdentitiesDefaultImplementation(apiResponseLocalVar, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);

                        Events.ExecuteOnListIdentities(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListIdentitiesDefaultImplementation(e, "/admin/identities", uriBuilderLocalVar.Path, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);
                Events.ExecuteOnErrorListIdentities(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListIdentitiesApiResponse"/>
        /// </summary>
        public partial class ListIdentitiesApiResponse : Ory.Kratos.Client.Client.ApiResponse, IListIdentitiesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListIdentitiesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListIdentitiesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitiesApiResponse(ILogger<ListIdentitiesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosIdentity>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosIdentity>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosIdentity>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListIdentityDevices(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateListIdentityDevices(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterListIdentityDevicesDefaultImplementation(IListIdentityDevicesApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterListIdentityDevices(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterListIdentityDevices(ref bool suppressDefaultLog, IListIdentityDevicesApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorListIdentityDevicesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListIdentityDevices(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorListIdentityDevices(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// List an Identity&#39;s trusted devices This endpoint returns all trusted devices for any sessions that belong to the given Identity.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentityDevicesApiResponse"/>&gt;</returns>
        public async Task<IListIdentityDevicesApiResponse?> ListIdentityDevicesOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListIdentityDevicesAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List an Identity&#39;s trusted devices This endpoint returns all trusted devices for any sessions that belong to the given Identity.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentityDevicesApiResponse"/>&gt;</returns>
        public async Task<IListIdentityDevicesApiResponse> ListIdentityDevicesAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListIdentityDevices(id);

                FormatListIdentityDevices(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}/devices";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListIdentityDevicesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListIdentityDevicesApiResponse>();

                        ListIdentityDevicesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/devices", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListIdentityDevicesDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnListIdentityDevices(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListIdentityDevicesDefaultImplementation(e, "/admin/identities/{id}/devices", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorListIdentityDevices(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListIdentityDevicesApiResponse"/>
        /// </summary>
        public partial class ListIdentityDevicesApiResponse : Ory.Kratos.Client.Client.ApiResponse, IListIdentityDevicesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListIdentityDevicesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListIdentityDevicesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentityDevicesApiResponse(ILogger<ListIdentityDevicesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosSessionDevice>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosSessionDevice>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosSessionDevice>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListIdentitySchemas(ref Option<long> perPage, ref Option<long> page, ref Option<long> pageSize, ref Option<string> pageToken);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="pageToken"></param>
        /// <returns></returns>
        private void ValidateListIdentitySchemas(Option<string> pageToken)
        {
            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        private void AfterListIdentitySchemasDefaultImplementation(IListIdentitySchemasApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken)
        {
            bool suppressDefaultLog = false;
            AfterListIdentitySchemas(ref suppressDefaultLog, apiResponseLocalVar, perPage, page, pageSize, pageToken);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        partial void AfterListIdentitySchemas(ref bool suppressDefaultLog, IListIdentitySchemasApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        private void OnErrorListIdentitySchemasDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListIdentitySchemas(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, perPage, page, pageSize, pageToken);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        partial void OnErrorListIdentitySchemas(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken);

        /// <summary>
        /// Get all Identity Schemas Returns a list of all identity schemas currently in use.
        /// </summary>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySchemasApiResponse?> ListIdentitySchemasOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListIdentitySchemasAsync(perPage, page, pageSize, pageToken, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Identity Schemas Returns a list of all identity schemas currently in use.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySchemasApiResponse> ListIdentitySchemasAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListIdentitySchemas(pageToken);

                FormatListIdentitySchemas(ref perPage, ref page, ref pageSize, ref pageToken);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/schemas";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListIdentitySchemasApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListIdentitySchemasApiResponse>();

                        ListIdentitySchemasApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schemas", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListIdentitySchemasDefaultImplementation(apiResponseLocalVar, perPage, page, pageSize, pageToken);

                        Events.ExecuteOnListIdentitySchemas(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListIdentitySchemasDefaultImplementation(e, "/schemas", uriBuilderLocalVar.Path, perPage, page, pageSize, pageToken);
                Events.ExecuteOnErrorListIdentitySchemas(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListIdentitySchemasApiResponse"/>
        /// </summary>
        public partial class ListIdentitySchemasApiResponse : Ory.Kratos.Client.Client.ApiResponse, IListIdentitySchemasApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListIdentitySchemasApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListIdentitySchemasApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitySchemasApiResponse(ILogger<ListIdentitySchemasApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosIdentitySchemaContainer>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosIdentitySchemaContainer>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosIdentitySchemaContainer>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListIdentitySessions(ref string id, ref Option<long> perPage, ref Option<long> page, ref Option<long> pageSize, ref Option<string> pageToken, ref Option<bool> active);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="pageToken"></param>
        /// <returns></returns>
        private void ValidateListIdentitySessions(string id, Option<string> pageToken)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        private void AfterListIdentitySessionsDefaultImplementation(IListIdentitySessionsApiResponse apiResponseLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active)
        {
            bool suppressDefaultLog = false;
            AfterListIdentitySessions(ref suppressDefaultLog, apiResponseLocalVar, id, perPage, page, pageSize, pageToken, active);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        partial void AfterListIdentitySessions(ref bool suppressDefaultLog, IListIdentitySessionsApiResponse apiResponseLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        private void OnErrorListIdentitySessionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListIdentitySessions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, perPage, page, pageSize, pageToken, active);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        partial void OnErrorListIdentitySessions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active);

        /// <summary>
        /// List an Identity&#39;s Sessions This endpoint returns all sessions that belong to the given Identity.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySessionsApiResponse?> ListIdentitySessionsOrDefaultAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListIdentitySessionsAsync(id, perPage, page, pageSize, pageToken, active, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List an Identity&#39;s Sessions This endpoint returns all sessions that belong to the given Identity.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySessionsApiResponse> ListIdentitySessionsAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListIdentitySessions(id, pageToken);

                FormatListIdentitySessions(ref id, ref perPage, ref page, ref pageSize, ref pageToken, ref active);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}/sessions";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListIdentitySessionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListIdentitySessionsApiResponse>();

                        ListIdentitySessionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/sessions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListIdentitySessionsDefaultImplementation(apiResponseLocalVar, id, perPage, page, pageSize, pageToken, active);

                        Events.ExecuteOnListIdentitySessions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListIdentitySessionsDefaultImplementation(e, "/admin/identities/{id}/sessions", uriBuilderLocalVar.Path, id, perPage, page, pageSize, pageToken, active);
                Events.ExecuteOnErrorListIdentitySessions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListIdentitySessionsApiResponse"/>
        /// </summary>
        public partial class ListIdentitySessionsApiResponse : Ory.Kratos.Client.Client.ApiResponse, IListIdentitySessionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListIdentitySessionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListIdentitySessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitySessionsApiResponse(ILogger<ListIdentitySessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosSession>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosSession>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosSession>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListSessions(ref Option<long> pageSize, ref Option<string> pageToken, ref Option<bool> active, Option<List<string>> expand);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="pageToken"></param>
        /// <param name="expand"></param>
        /// <returns></returns>
        private void ValidateListSessions(Option<string> pageToken, Option<List<string>> expand)
        {
            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));

            if (expand.IsSet && expand.Value == null)
                throw new ArgumentNullException(nameof(expand));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        private void AfterListSessionsDefaultImplementation(IListSessionsApiResponse apiResponseLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand)
        {
            bool suppressDefaultLog = false;
            AfterListSessions(ref suppressDefaultLog, apiResponseLocalVar, pageSize, pageToken, active, expand);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        partial void AfterListSessions(ref bool suppressDefaultLog, IListSessionsApiResponse apiResponseLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        private void OnErrorListSessionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListSessions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, pageSize, pageToken, active, expand);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        partial void OnErrorListSessions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand);

        /// <summary>
        /// List All Sessions Listing all sessions that exist.
        /// </summary>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>&gt;</returns>
        public async Task<IListSessionsApiResponse?> ListSessionsOrDefaultAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListSessionsAsync(pageSize, pageToken, active, expand, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List All Sessions Listing all sessions that exist.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>&gt;</returns>
        public async Task<IListSessionsApiResponse> ListSessionsAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListSessions(pageToken, expand);

                FormatListSessions(ref pageSize, ref pageToken, ref active, expand);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/sessions";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (expand.IsSet)
                        parseQueryStringLocalVar["expand"] = ClientUtils.ParameterToString(expand.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListSessionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListSessionsApiResponse>();

                        ListSessionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListSessionsDefaultImplementation(apiResponseLocalVar, pageSize, pageToken, active, expand);

                        Events.ExecuteOnListSessions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListSessionsDefaultImplementation(e, "/admin/sessions", uriBuilderLocalVar.Path, pageSize, pageToken, active, expand);
                Events.ExecuteOnErrorListSessions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListSessionsApiResponse"/>
        /// </summary>
        public partial class ListSessionsApiResponse : Ory.Kratos.Client.Client.ApiResponse, IListSessionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListSessionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListSessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSessionsApiResponse(ILogger<ListSessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosSession>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosSession>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosSession>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPatchIdentity(ref string id, Option<List<KratosJsonPatch>> kratosJsonPatch);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        /// <returns></returns>
        private void ValidatePatchIdentity(string id, Option<List<KratosJsonPatch>> kratosJsonPatch)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (kratosJsonPatch.IsSet && kratosJsonPatch.Value == null)
                throw new ArgumentNullException(nameof(kratosJsonPatch));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        private void AfterPatchIdentityDefaultImplementation(IPatchIdentityApiResponse apiResponseLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch)
        {
            bool suppressDefaultLog = false;
            AfterPatchIdentity(ref suppressDefaultLog, apiResponseLocalVar, id, kratosJsonPatch);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        partial void AfterPatchIdentity(ref bool suppressDefaultLog, IPatchIdentityApiResponse apiResponseLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        private void OnErrorPatchIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPatchIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, kratosJsonPatch);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        partial void OnErrorPatchIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch);

        /// <summary>
        /// Patch an Identity Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </summary>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>&gt;</returns>
        public async Task<IPatchIdentityApiResponse?> PatchIdentityOrDefaultAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PatchIdentityAsync(id, kratosJsonPatch, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Patch an Identity Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>&gt;</returns>
        public async Task<IPatchIdentityApiResponse> PatchIdentityAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePatchIdentity(id, kratosJsonPatch);

                FormatPatchIdentity(ref id, kratosJsonPatch);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (kratosJsonPatch.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosJsonPatch.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosJsonPatch.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PatchIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PatchIdentityApiResponse>();

                        PatchIdentityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPatchIdentityDefaultImplementation(apiResponseLocalVar, id, kratosJsonPatch);

                        Events.ExecuteOnPatchIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPatchIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id, kratosJsonPatch);
                Events.ExecuteOnErrorPatchIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PatchIdentityApiResponse"/>
        /// </summary>
        public partial class PatchIdentityApiResponse : Ory.Kratos.Client.Client.ApiResponse, IPatchIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PatchIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PatchIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PatchIdentityApiResponse(ILogger<PatchIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPatchIdentityDevices(ref string id, ref string deviceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidatePatchIdentityDevices(string id, string deviceId)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (deviceId == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="deviceId"></param>
        private void AfterPatchIdentityDevicesDefaultImplementation(IPatchIdentityDevicesApiResponse apiResponseLocalVar, string id, string deviceId)
        {
            bool suppressDefaultLog = false;
            AfterPatchIdentityDevices(ref suppressDefaultLog, apiResponseLocalVar, id, deviceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="deviceId"></param>
        partial void AfterPatchIdentityDevices(ref bool suppressDefaultLog, IPatchIdentityDevicesApiResponse apiResponseLocalVar, string id, string deviceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="deviceId"></param>
        private void OnErrorPatchIdentityDevicesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string deviceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPatchIdentityDevices(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, deviceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="deviceId"></param>
        partial void OnErrorPatchIdentityDevices(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string deviceId);

        /// <summary>
        /// Patch an Identity&#39;s devices Partially updates an identity&#39;s device&#39;s trusted field using [JSON Patch](https://jsonpatch.com/). Only the field &#x60;trusted&#x60; can be updated using this method. Even that can only be set to &#x60;false&#x60; using this method.
        /// </summary>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="deviceId">DeviceID is the Identity&#39;s Device&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityDevicesApiResponse"/>&gt;</returns>
        public async Task<IPatchIdentityDevicesApiResponse?> PatchIdentityDevicesOrDefaultAsync(string id, string deviceId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PatchIdentityDevicesAsync(id, deviceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Patch an Identity&#39;s devices Partially updates an identity&#39;s device&#39;s trusted field using [JSON Patch](https://jsonpatch.com/). Only the field &#x60;trusted&#x60; can be updated using this method. Even that can only be set to &#x60;false&#x60; using this method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="deviceId">DeviceID is the Identity&#39;s Device&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityDevicesApiResponse"/>&gt;</returns>
        public async Task<IPatchIdentityDevicesApiResponse> PatchIdentityDevicesAsync(string id, string deviceId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePatchIdentityDevices(id, deviceId);

                FormatPatchIdentityDevices(ref id, ref deviceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}/devices/{device_id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bdevice_id%7D", Uri.EscapeDataString(deviceId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PatchIdentityDevicesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PatchIdentityDevicesApiResponse>();

                        PatchIdentityDevicesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/devices/{device_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPatchIdentityDevicesDefaultImplementation(apiResponseLocalVar, id, deviceId);

                        Events.ExecuteOnPatchIdentityDevices(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPatchIdentityDevicesDefaultImplementation(e, "/admin/identities/{id}/devices/{device_id}", uriBuilderLocalVar.Path, id, deviceId);
                Events.ExecuteOnErrorPatchIdentityDevices(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PatchIdentityDevicesApiResponse"/>
        /// </summary>
        public partial class PatchIdentityDevicesApiResponse : Ory.Kratos.Client.Client.ApiResponse, IPatchIdentityDevicesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PatchIdentityDevicesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PatchIdentityDevicesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PatchIdentityDevicesApiResponse(ILogger<PatchIdentityDevicesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosSessionDevice>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosSessionDevice>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosSessionDevice>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateIdentity(ref string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        /// <returns></returns>
        private void ValidateUpdateIdentity(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (kratosUpdateIdentityBody.IsSet && kratosUpdateIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosUpdateIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        private void AfterUpdateIdentityDefaultImplementation(IUpdateIdentityApiResponse apiResponseLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateIdentity(ref suppressDefaultLog, apiResponseLocalVar, id, kratosUpdateIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        partial void AfterUpdateIdentity(ref bool suppressDefaultLog, IUpdateIdentityApiResponse apiResponseLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        private void OnErrorUpdateIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, kratosUpdateIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        partial void OnErrorUpdateIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody);

        /// <summary>
        /// Update an Identity This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload (except credentials) is expected. It is possible to update the identity&#39;s credentials as well.
        /// </summary>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>&gt;</returns>
        public async Task<IUpdateIdentityApiResponse?> UpdateIdentityOrDefaultAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateIdentityAsync(id, kratosUpdateIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update an Identity This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload (except credentials) is expected. It is possible to update the identity&#39;s credentials as well.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>&gt;</returns>
        public async Task<IUpdateIdentityApiResponse> UpdateIdentityAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateIdentity(id, kratosUpdateIdentityBody);

                FormatUpdateIdentity(ref id, kratosUpdateIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/admin/identities/{id}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (kratosUpdateIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosUpdateIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosUpdateIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateIdentityApiResponse>();

                        UpdateIdentityApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateIdentityDefaultImplementation(apiResponseLocalVar, id, kratosUpdateIdentityBody);

                        Events.ExecuteOnUpdateIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id, kratosUpdateIdentityBody);
                Events.ExecuteOnErrorUpdateIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateIdentityApiResponse"/>
        /// </summary>
        public partial class UpdateIdentityApiResponse : Ory.Kratos.Client.Client.ApiResponse, IUpdateIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateIdentityApiResponse(ILogger<UpdateIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public Ory.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<Ory.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out Ory.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
